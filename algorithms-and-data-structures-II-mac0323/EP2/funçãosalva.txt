No* A23:: insereA23(No* raiz, string key, Item item){
    //cout << key << endl;
    //cout << "oie" << endl;

    // inserção em folha
    if(raiz == nullptr){
        raiz = (No*)malloc(sizeof(No));
        raiz->palavra1 = key;
        raiz->item1 = item;
        raiz->esq = raiz->dir = raiz->meio = raiz->pai = nullptr;
        raiz->tresNo = false;

        if(this->tam == 0)
            this->raiz = raiz;

        this->tam++;

        return raiz;
    }

    // pensar no caso em que já está na árvore
    // palavra1 == key
    if(strcmp(raiz->palavra1.c_str(), key.c_str()) == 0){
        raiz->item1.qntOcorrencias++;
        return raiz;
    }

    // palavra2 == key
    if(raiz->tresNo)
        if(strcmp(raiz->palavra2.c_str(), key.c_str()) == 0){
            raiz->item2.qntOcorrencias++;
            return raiz;
        }

    // inserção em folha 
    if(raiz->esq == nullptr && raiz->dir == nullptr){

        // a raiz possui apenas uma chave
        if(!raiz->tresNo){
            //cout << "entrou nesse if da linha 96" << endl;
            // key < palavra1
            if(strcmp(key.c_str(), raiz->palavra1.c_str()) < 0){
                string aux1 = raiz->palavra1;
                Item aux2 = raiz->item1;

                raiz->palavra1 = key;
                raiz->item1 = item;
                raiz->palavra2 = aux1;
                raiz->item2 = aux2;
            }
            // key > palavra1
            else if(strcmp(key.c_str(), raiz->palavra1.c_str()) > 0){
                raiz->palavra2 = key;
                raiz->item2 = item;
                //cout << "lacrador" << endl;
            }

            raiz->tresNo = true;
            this->tam++;
            return raiz;
        }
        // até aqui eu acho que ta ok
//////////////////////////////////////////////////////////////////////////////////////////////////
        // COMO QUE SOBE A PORRA DO PROBLEMA PORRA
        // o nó é tresNó já
        // palavra1 > key -> key < palavra1 < palavra2
        if(strcmp(raiz->palavra1.c_str(), key.c_str()) > 0){
            string aux1 = raiz->palavra1;
            Item aux2 = raiz->item1;

            raiz->palavra1 = key;
            raiz->item1 = item;

            // quando a raiz original não tem pai, agr vai ter
            if(raiz->pai == nullptr){
                this->raiz = criaNo(aux1, aux2, nullptr);
                this->tam++;
                this->raiz->esq = criaNo(key, item, this->raiz);
                this->raiz->dir = criaNo(raiz->palavra2, raiz->item2, this->raiz);
                free(raiz);
                cout << "entrou aqui2" << endl;
                return this->raiz;
            }

            // se já tem pai, a gnt tenta inserir a string e o item no pai e vai subindo o problema 
            else 
                raiz->pai = insereA23(raiz->pai, aux1, aux2); // sla oq eu to fazendo
            
        }

        // palavra1 < key
        else{
            // palavra2 > key -> palavra1 < key < palavra2
            if(strcmp(raiz->palavra2.c_str(), key.c_str()) > 0){
                /*if(raiz->pai == nullptr){
                    this->raiz = criaNo(key, item, nullptr);
                    this->tam++;
                    this->raiz->esq = criaNo(raiz->palavra1, raiz->item1, this->raiz);
                    this->raiz->dir = criaNo(raiz->palavra2, raiz->item2, this->raiz);
                    free(raiz);
                    cout << "entrou aqui1" << endl;
                    return this->raiz;
                }
                else
                    raiz->pai = insereA23(raiz->pai, key, item);*/ // sla oq eu to fazendo
                return(criaNo(key, item, nullptr));
            }

            // palavra2 < key -> palavra1 < palavra2 < key
            else{
                string aux1;
                Item aux2;

                aux1 = raiz->palavra2;
                aux2 = raiz->item2;

                raiz->palavra2 = key;
                raiz->item2 = item;

                /*if(raiz->pai == nullptr){
                    this->raiz = criaNo(aux1, aux2, nullptr);
                    this->tam++;
                    this->raiz->esq = criaNo(raiz->palavra1, raiz->item1, this->raiz);
                    this->raiz->dir = criaNo(key, item, this->raiz);
                    free(raiz);
                    cout << "entrou aq3" << endl;
                    return this->raiz;
                }
                else
                    insereA23(raiz->pai, aux1, aux2);*/ // sla oq eu to fazendo
                return(criaNo(aux1, aux2, nullptr));
            

            }
        }

    }

    No* aux;

    // palavra1 > key
    if(strcmp(raiz->palavra1.c_str(), key.c_str()) > 0){
        aux = insereA23(raiz->esq, key, item);

    }
    
    // palavra1 < k && palavra2 > k
    else if(raiz->tresNo && strcmp(raiz->palavra2.c_str(), key.c_str()) > 0){
        aux = insereA23(raiz->meio, key, item);
    }

    else{
        aux = insereA23(raiz->dir, key, item);
    }

    return raiz;
    
}